#Initial commit for a BattleShips solver

#Board dataframe setup
import os
os.system('clear')

import pandas as pd
import math as math
import numpy as np

#Required functions
#####

#Initial input
#####

#Overal solver logic loop
# Rule out cells in full rows
# Rule out cells touching a ship
# Include cells that are known extensions of a partial ship

#Intial board setup
#None = unknown cell
#0 = Empty - empty cell
#1 = Single = Round single cell ship
#2 = Up - End of a ship where the connecting side is facing up
#3 = Right - similar to above
#4 = Down - similar to above
#5 = Left - similar to above
#6 = Middle - middle section of a ship
#7 = Boat of unknown type - could be middle or end of a boat

#Data input template
#data = {
#  "col1": [None,],
#  "col2": [None,],
#  "col3": [None,],
#  "col4": [None,],
#  "col5": [None,],
#  "col6": [None,]
#}
 
data = {
  "col1": [None,None,None,None,None,None],
  "col2": [None,None,None,None,None,None],
  "col3": [None,None,None,None,None,None],
  "col4": [None,None,None,None,2,None],
  "col5": [None,None,None,None,None,None],
  "col6": [None,None,0,None,None,None]
}
ships = {
    "5cell": [0],
    "4cell": [0],
    "3cell": [1],
    "2cell": [2],
    "1cell": [3]
}
nums = {
  "rows": [4,0,1,3,1,1],
  "cols": [0,3,1,3,0,3]
}

#load data into a DataFrame object:
df = pd.DataFrame(data)
ships_df = pd.DataFrame(ships)
nums_df = pd.DataFrame(nums)
print(nums_df)

#Get shape of dataframe
shape = df.shape

#Create a base possibiilities dataframe - mutliple possibilities need to be stored as a string
possibilities_df = df.astype(object)

None_count=0 #Number of unknown cells
lst = list(range(0,8))
for i in range(0,shape[0]):
  for j in range(0,shape[1]):
    if possibilities_df.iloc[i,j] == None or math.isnan(possibilities_df.iloc[i,j]) == True:
      None_count += 1
      possibilities_df.iloc[i,j] = str(lst)
    else:
      possibilities_df.iloc[i,j] = int(possibilities_df.iloc[i,j])

possibilities_df_orig = possibilities_df
print(possibilities_df)

#Overall looper, puzzle loops until is_done=1
is_done = 0
count=0
solving_step=0

os.system('clear')
while is_done == 0:
  if count >= 500:
    print('The puzzle has not been solved after 500+ steps')
    count += 1
    print('Final state after', count, 'steps')
    print(possibilities_df)
    is_done = 1
  elif None_count == 0: 
    is_done=1
    print('The puzzle is done after',count,'steps')
  else:
    #Iterate for known boats
    for i in range(0,shape[0]):
      for j in range(0,shape[1]):
        if type(possibilities_df.iloc[i,j]) is int and possibilities_df.iloc[i,j] >= 1:
            #For each element if a cell is touching a known boat diagonally, mark it as Empty=0
            if i+1 < shape[0] and j+1 < shape[1] and type(possibilities_df.iloc[i+1,j+1]) is str:
                possibilities_df.iloc[i+1,j+1] = 0
                None_count -= 1
                print('Cell',i,',',j,'has been solved as Empty as it diagonally touches a known boat')
            if i+1 < shape[0] and j-1 >= 0 and type(possibilities_df.iloc[i+1,j-1]) is str:
                possibilities_df.iloc[i+1,j-1] = 0
                None_count -= 1
                print('Cell',i,',',j,'has been solved as Empty as it diagonally touches a known boat')
            if i-1 >= 0 and j+1 < shape[1] and type(possibilities_df.iloc[i-1,j+1]) is str:
                possibilities_df.iloc[i-1,j+1] = 0
                None_count -= 1
                print('Cell',i,',',j,'has been solved as Empty as it diagonally touches a known boat')
            if i-1 >= 0 and j-1 >= 0 and type(possibilities_df.iloc[i-1,j-1]) is str:
                possibilities_df.iloc[i-1,j-1] = 0
                None_count -= 1
                print('Cell',i,',',j,'has been solved as Empty as it diagonally touches a known boat')
          # If its a known boat, mark the other adjacent cells as empty (except for flat side)
          #Up
            if possibilities_df.iloc[i,j] in [1,3,4,5] and i-1 >= 0 and type(possibilities_df.iloc[i-1,j]) is str:
                possibilities_df.iloc[i-1,j] = 0
                None_count -= 1
                print('Cell',i-1,',',j,'has been solved as Empty as it touches a known boat edge')
            #Right
            if possibilities_df.iloc[i,j] in [1,2,4,5] and j+1 < shape[1] and type(possibilities_df.iloc[i,j+1]) is str:
                possibilities_df.iloc[i,j+1] = 0
                None_count -= 1
                print('Cell',i,',',j+1,'has been solved as Empty as it touches a known boat edge')
            #Down
            if possibilities_df.iloc[i,j] in [1,2,3,5] and i+1 < shape[0] and type(possibilities_df.iloc[i+1,j]) is str:
                possibilities_df.iloc[i+1,j] = 0
                None_count -= 1
                print('Cell',i+1,',',j,'has been solved as Empty as it touches a known boat edge')
            #Left
            if possibilities_df.iloc[i,j] in [1,2,3,4] and j-1 >= 0 and type(possibilities_df.iloc[i,j-1]) is str:
                possibilities_df.iloc[i,j-1] = 0
                None_count -= 1
                print('Cell',i,',',j-1,'has been solved as Empty as it touches a known boat edge')
            
            #If a boat is a known end (Up,Right,Down, Left) mark the cell on the flat-side as 7- Boat type unknown
            if possibilities_df.iloc[i,j] == 2 and i-1 >= 0 and type(possibilities_df.iloc[i-1,j]) is str:
                possibilities_df.iloc[i-1,j] = int(7)
                print('Cell',i-1,',',j,'has been marked as "Boat-Unknown" as it touches a known boat join')
            if possibilities_df.iloc[i,j] == 3 and j+1 < shape[1] and type(possibilities_df.iloc[i,j+1]) is str:
                possibilities_df.iloc[i,j+1] = int(7)
                print('Cell',i,',',j+1,'has been marked as "Boat-Unknown" as it touches a known boat join')
            if possibilities_df.iloc[i,j] == 4 and i+1 < shape[0] and type(possibilities_df.iloc[i+1,j]) is str:
                possibilities_df.iloc[i+1,j] = int(7)
                print('Cell',i+1,',',j,'has been marked as "Boat-Unknown" as it touches a known boat join')
            if possibilities_df.iloc[i,j] == 5 and j-1 >= 0 and type(possibilities_df.iloc[i,j-1]) is str:
                possibilities_df.iloc[i,j-1] = int(7)
                print('Cell',i,',',j-1,'has been marked as "Boat-Unknown" as it touches a known boat join')
        count += 1   

    #Iterate for rows and cols
    #For each row, count how many cells are boats and if it matches total, mark unknown squares as Empty
    for i in range(0,shape[0]):
        row_boat_count = 0
        row_unknown_count = 0
        row_empty_count = 0
        #Count how many cells are boats
        for j in range(0,shape[1]):
            if type(possibilities_df.iloc[i,j]) is int and possibilities_df.iloc[i,j] >= 1:
                row_boat_count += 1
            elif type(possibilities_df.iloc[i,j]) is str and possibilities_df.iloc[i,j] == 0:
                row_empty_count += 1
        row_unknown_count = shape[1] - row_boat_count - row_empty_count
        
        #If the count matches the row total, mark the rest as empty
        if row_boat_count == nums_df.iloc[i,0]:
            for j in range(0,shape[1]):
                if type(possibilities_df.iloc[i,j]) is str:
                    possibilities_df.iloc[i,j] = 0
                    None_count -= 1
                    print('Cell',i,',',j,'has been solved as Empty as the row',i,'already has the maximum number of boats')

        if i ==5:
            print('row_boat_count is',row_boat_count)
            print('row unknown count is',row_unknown_count)
            print('row empty count',row_empty_count)
            print('row total is',nums_df.iloc[i,0])
        #if the number of unknown cells + known boats = row total, mark the rest as 7=Boat-Unknown
        if row_unknown_count + row_boat_count == nums_df.iloc[i,0]:
            for j in range(0,shape[1]):
                if type(possibilities_df.iloc[i,j]) is str:
                    possibilities_df.iloc[i,j] = 7
                    print('Cell',i,',',j,'has been marked as "Boat-Unknown" as it must be a boat to satisfy the row',i,'total')
              
        
            
          
    #Same logic as above but for columns
    #For each col, count how many cells are boats and if it matches total, mark unknown squares as Empty
    skip=0
    if skip==0:
        for j in range(0,shape[1]):
            col_boat_count = 0
            col_unknown_count = 0
            col_empty_count = 0
            #Count how many cells are boats
            for i in range(0,shape[0]):
                if type(possibilities_df.iloc[i,j]) is int and possibilities_df.iloc[i,j] >= 1:
                    col_boat_count += 1
                    #print(i)
                elif type(possibilities_df.iloc[i,j]) is int and possibilities_df.iloc[i,j] == 0:
                    col_empty_count += 1
            col_unknown_count = shape[0]- col_boat_count - col_empty_count
                
            
            #If the count matches the col total, mark the rest as empty
            if col_boat_count == nums_df.iloc[j,1]:
                for i in range(0,shape[0]):
                    if type(possibilities_df.iloc[i,j]) is str:
                        possibilities_df.iloc[i,j] = 0
                        None_count -= 1
                        print('Cell',i,',',j,'has been solved as Empty as the col',j,'already has the maximum number of boats')
        
            #if the number of unknown cells + known boats = col total, mark the rest as 7=Boat-Unknown
            if col_unknown_count + col_boat_count == nums_df.iloc[j,1]:
                for i in range(0,shape[0]):
                    if type(possibilities_df.iloc[i,j]) is str:
                        possibilities_df.iloc[i,j] = 7
                        print('Cell',i,',',j,'has been marked as "Boat-Unknown" as it must be a boat to satisfy the column',j,'total')
              
            count += 1

    #For each boat of unknown type = 7 - try and convert it to a known type
        #e.g. surrounded by empty = single
        #e.g. if it has adjacents on two sides its a middle
        #if it has an adjacent on one side and a water on opposite, its an end
    

    
      #input additional logic to solve puzzle
      #e.g. existing tuples and higher level logic
    
    # Logic to look for tuples
    #logic to look for X-pairs
    #print(count)
print(possibilities_df)
